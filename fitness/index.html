<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fitness Plotter</title>
    <link rel="icon" type="image/x-icon" href="img/icons8-weightlifting-arcade-96.png">

    <meta http-equiv='cache-control' content='no-cache'> 
    <meta http-equiv='expires' content='0'> 
    <meta http-equiv='pragma' content='no-cache'>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <script src="lib/papaparse.min.js"></script>
    <script src="lib/d3.min.js"></script>
    <script src="lib/billboard.js"></script> 
<!-- TODO: switch to the 'min' version of billboard -->
    <link rel="stylesheet" href="style/billboard.css">
<!-- 
Sublime default color scheme:
dark grey   rgb(48, 56, 65)
white       rgb(216 222 233)
red         rgb(236 95 102)
green       rgb(153 199 148)
teal        rgb(95 180 180)
grey        rgb(132 139 149)
purple      rgb(198 149 198)
yellow      rgb(249 174 88)
blue        rgb(102 153 204)
green       rgb(153 199 148
orange      rgb(248 123 88)

light gray header rgb(79 86 94)
dark gray footer rgb(46 50 56)

default bb color pallete: 
31 119 180
255 127 14
44 160 44
214 39 40
-->
    <style>
        body {
            background-color: rgb(48, 56, 65);
            color: rgb(216, 222, 233);
        }

        a {
            color: rgb(102 153 204)
        }

        /* Style the button that is used to open and close the collapsible content */
        .collapsible {
            background-color: rgb(46 50 56); /*rgb(79 86 94);*/ /*rgb(132 139 149);*/
            color: rgb(95 180 180);
            cursor: pointer;
            padding: 18px;
            padding-left: 15%;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.6em;
            font-family: monospace, monospace;
        }

        /* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
        /*.active, */.collapsible:hover {
            color: rgb(236 95 102);
        }

        /* Style the collapsible content.  */
        .content {
            padding: 0 18px;
            overflow: hidden;
            background-color: rgb(48, 56, 65);
        }
    </style>
</head>
<body>

<script type="text/javascript">   
const short_month_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

function to_ascii(s) {
    return s.replaceAll("[^\\p{ASCII}]");
}

function to_id_name(s) {
    return s
        .replaceAll(/ /g, "_") // replace space with _
        .replace(/[\])}[{(]/g, ""); // remove brackets, parens, braces
}

// Note this function will "snap" to new values if SMA is 0
function simpleMovingAverage(input, interval) {
    const length = input.length;
    let output = [];
    let i = 0;
    let sum = 0;

    let snap = 0; // typically, index of first non-trivial value
    while (i < interval && i < length) {
        if (sum == 0) {
            sum = input[i];
            snap = 0;
        } else {
            sum += input[i];
        }
        i++;
        output.push(sum / (i - snap));
    }

    while (interval <= i && i < length) {
        if (sum == 0) {
            sum = input[i];
            snap = i;
            output.push( sum );
        } else {
            if (i - interval < snap) {
                // still warming up
                sum += input[i];
                output.push(sum / (1 + (i - snap)));
            } else {
                // nominal case
                sum += input[i] - input[i - interval];
                output.push(sum / interval);
            }
        }
        i++;
    }

    return output;
}

function add_days(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

// Specialized for the results from PapaParser
function transpose(data) {
    let output = {};
    let fields = data[0].length;
    // Probably a more JS way of doing this but yolo
    for (var field_id = 0; field_id < fields; field_id++) {
        output[data[0][field_id]] = [];
        // Date is special, handle it differently
        if ("Date" === data[0][field_id]) {
            // const start = new Date("February 11, 2023");
            for (var i = 1; i < data.length; i++) {
                // This setYear hack will need updating :)
                // output[data[0][field_id]].push( add_days(start, i-1) );
                output[data[0][field_id]].push(new Date(data[i][field_id]).setYear(2023));
            }
        } else {
            for (var i = 1; i < data.length; i++) {
                const datum = parseFloat(
                    // Must remove all commas from string before parsing...
                    data[i][field_id].replace(/\,/g, "")
                );
                output[data[0][field_id]].push(
                    // Replaces NaN with 0
                    datum ? datum : 0
                );
            }
        }
    }

    for (field of ["Active Energy [C]", "Resting Energy [C]"]) {
        for (var i = 0; i < output[field].length; i++) {
            output[field][i] = -output[field][i];
        }
    }

    return output;
}

// Makes the buttons collapse next element when clicked
function collapsible() {
    var coll = document.getElementsByClassName("collapsible");
    for (var i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function () {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.display === "none") {
                content.style.display = "block";
            } else {
                content.style.display = "none";
            }
        });
    }
}

function arrayMax(array) { return array.reduce(function(a, b) { return Math.max(a, b); }); }
function arrayMin(array) { return array.reduce(function(a, b) { return Math.min(a, b); }); }

function hadamard_sum(array) {
    const num_arrays = array.length;
    const len = array[0].length;
    let output = [...array[0]];
    for (let array_index = 1; array_index < num_arrays; array_index++) {
        for (let idx = 0; idx < len; idx++) {
            output[idx] += array[array_index][idx];
        }
    }
    return output;
}

Array.prototype.SumArray = function (arr) {
    var sum = this.map(function (num, idx) {
        return num + arr[idx];
    });
    return sum;
}

function cumsum(x) { return x.map((sum = 0, n => sum += n)); }

function daily_delta(x) {
    var out = [0];
    for (var i = 1; i < x.length; i++) {
        out.push(x[i] - x[i-1]);
    }
    return out;
}

function add_sma(data, field, smoothing = 7) {
    data[field + " (SMA)"] = simpleMovingAverage(data[field], smoothing);
}

// All the fields which are functions of the raw data are added here. 
function compute_derived(raw_data) {
    const len = raw_data["Date"].length;
    var data = raw_data;
    data["Deficit [C]"] = hadamard_sum([
        raw_data["Resting Energy [C]"], 
        raw_data["Active Energy [C]"], 
        raw_data["Food Energy [C]"]
    ]);
    data["Active Weight Loss [lbs]"] = [];
    for (let i = 0; i < len; i++) {
        data["Active Weight Loss [lbs]"].push( data["Active Energy [C]"][i] / -3500.0);
    }
    data["Cumulative Deficit [C]"] = cumsum(data["Deficit [C]"]);
    data["Expected Weight Loss [lbs]"] = [];
    for (let i = 0; i < len; i++) {
        data["Expected Weight Loss [lbs]"].push(data["Cumulative Deficit [C]"][i] / -3500.0);
    }
    add_sma(data, "Expected Weight Loss [lbs]");
    data["Observed Weight Loss [lbs]"] = [];
    for (let i = 0; i < len; i++) {
        data["Observed Weight Loss [lbs]"].push(data["Weight [lbs]"][0] - data["Weight [lbs]"][i]);
    }
    add_sma(data, "Observed Weight Loss [lbs]");
    data["Anomalous Weight Loss [lbs]"] = [];
    for (let i = 0; i < len; i++) {
        data["Anomalous Weight Loss [lbs]"].push(data["Observed Weight Loss [lbs]"][i] - data["Expected Weight Loss [lbs]"][i]);
    }
    add_sma(data, "Anomalous Weight Loss [lbs]");
    data["Weekly Delta of Weight [lbs]"] = [];
    for (let i = 0; i < 7; i++) {
        data["Weekly Delta of Weight [lbs]"].push(data["Weight [lbs]"][0] - data["Weight [lbs]"][i]);
    }
    for (let i = 7; i < len; i++) {
        data["Weekly Delta of Weight [lbs]"].push(data["Weight [lbs]"][i-7] - data["Weight [lbs]"][i]);
    }
    add_sma(data, "Weekly Delta of Weight [lbs]");
    return data;
}

function treatAsUTC(date) {
    var result = new Date(date);
    result.setMinutes(result.getMinutes() - result.getTimezoneOffset());
    return result;
}

function daysBetween(startDate, endDate) {
    var millisecondsPerDay = 24 * 60 * 60 * 1000;
    return (treatAsUTC(endDate) - treatAsUTC(startDate)) / millisecondsPerDay;
}

function days_in_domain(domain) {
    return daysBetween(domain[0], domain[1]);
}

function hide_personal() {
    document.querySelectorAll(".csp").forEach(el => {el.innerHTML = "";});
}

function handle_files(input) {
    hide_personal()
    let file = input.files[0];
    Papa.parse(file, {
        complete: function(results) {
            update(results.data);
        }
    });
}
</script>

<button type="button" class="collapsible">Intro</button>
<div class="content">
<div class="csp"><p>
I'm a 6'4", 36 year old man who started trying to get in shape on Feb 11th 2023.
</p></div>

<p>Click on the headers to collapse them.</p>

<p>"SMA" stands for "simple moving average". It's a 7 day trailing average unless specified, or the proceeding window of valid data is too short. </p>

<p>You can click on the legend to disable part of the plot.</p>

<p>You can zoom in on the plots by selecting a region.</p>

<p>You can also try with your own CSV file, <a href="Data-Raw.csv" target="_blank">formatted like this</a> (column order shouldn't matter). <input type="file" id="input"/ onchange="handle_files(this)"></p>

<p>You can alternatively host your CSV file somewhere and pass the path to it as a URL parameter, like so: https://csp256.github.io/fitness/index.html?csv=https://www.yourdomain.com/your_data.csv</p>
</div>

<button type="button" class="collapsible">Weight</button>
<div class="content">
    <div id="Weight_lbs" class="bb"></div>
    <div id="Daily_Delta_Weight_lbs"></div>
    <div id="Weekly_Delta_of_Weight_lbs"></div>
    <div id="Cumulative_Active_Weight_Loss_lbs"></div>
    <div class="markdown">
<p>Pounds of weight lost from exercise. This is probably an underestimate by about 10%. For more info see "Active Energy [C]" under the "Calorie" header.</p>
    </div>
</div>



<button type="button" class="collapsible">Macros</button>
<div class="content">
    <div id="Protein_g"></div>
    <div id="Fat_g"></div>
    <div id="Carbs_g"></div>
</div>



<button type="button" class="collapsible">Exercise</button>
<div class="content">
    <div id="Walking_Steps"></div>
    <div id="Walking_mi"></div>
    <div class="markdown">
<div class="csp"><p>For most data points, if I walk or eat etc after midnight I make sure to correctly attribute that to the previous day. </p>

<p>However, I initially only manually recorded <em>steps</em> but not <em>miles</em>. I do not have the ability to retroactively make that correction.</p>

<p>Thus, this data is "unadjusted".</p></div>
    </div>
    <div id="Cumulative_Walking_mi"></div>

</div>



<button type="button" class="collapsible">Calories</button>
<div class="content">
    <div id="Daily_Calories_C"></div>
    <div class="markdown">
<div class="csp"><p>Active and resting energy are pulled from the Apple Health iPhone app. I don't have an Apple Watch. </p></div>
    </div>
    <div id="Deficit_C"></div>
    <div id="Food_Energy_C"></div>
    <div id="TDEE_C"></div>
    <div id="Active_Energy_C"></div>
    <div class="markdown">
<p>When exercising, only a portion of the increase calorie burn falls under "active energy". The justification for this I am not 100% sure about. Resting energy will increase by about 10% of the active energy. </p>
    </div>
    <div id="Resting_Energy_C"></div>
    <div class="markdown">
<div class="csp"><p>Resting energy is also "unadjusted", like miles walked. As I often exercise after midnight, this means the recorded resting energy might be elevated the day <em>after</em> the actual exercise.</p></div>
    </div>
</div>



<button type="button" class="collapsible">Analysis</button>
<div class="content">
    <div id="Observed_v_Expected_lbs"></div>
    <div class="markdown">
<p>Expected weight loss is calculated assuming the cumulative caloric deficit is satisfied entirely through fat catabolism. (3,500 Calories per pound of fat)</p>
    </div>
    <div id="Anomalous_Weight_Loss_lbs"></div>
    <div class="markdown">
<p>This is the discrepency between the simplistic "expected" weight loss and the actual observed weight loss.</p>

<p>There's actually an off-by-one error on some of this logic I haven't bothered to fix because weight is measured before that day's exercise. It doesn't <em>really</em> matter though. </p>
    </div>
</div>


<script>

const palette = [
    "rgba(31 119 180 255)",
    "rgba(255 127 14 255)",
    "rgba(44 160 44 255)",
    "rgba(214 39 40 255)",
    ];

function plot_obj_set_options(obj, data) {
    obj.clipPath = true;
    obj.axis = {
        x: {
            type: "timeseries",
            tick: {
                centered: true,
                fit: false,
                count: 8,
                multiline: false,
                autorotate: true,
                rotate: 90,
                format: function(d) {
                    return short_month_names[d.getMonth()] + " " + d.getDate();
                },
                culling: false,
                outer: true,
                values: data["Date"],
            },
        },
        y: {
            tick: {
                outer: false,
                format: function(s) { return s.toLocaleString(); }
            },
            padding: {
                top: 10,
                bottom: 10
            }
        },
        y2: {
            tick: {
                outer: false,
                format: function(s) { return s.toLocaleString(); }
            },
            show: true,
        }
    };

    obj.scatter = {zerobased:true};
    obj.line = {zerobased:true};

    obj.grid = {
        focus: {
            show: true,
            y: true
        },
        y: {
            show: true
        }
    };

    obj.zoom = {
        enabled: true,
        type: "drag",
        rescale: false,
        // onzoomstart: function() {
        // },
        // onzoom: function(domain) {
        // },
        // onzoomend: function(domain) {
        // }
    };
    // if (700 <= document.body.clientWidth) {
    //     obj.zoom.type = "drag";
    // }

    obj.onrendered = function() {
        // if (typeof this.rendered_before === "undefined") {
        //     this.rendered_before = true;
        //     return;
        // }
        const domain = this.internal.zoom.getDomain();
        const days = days_in_domain(domain);

        const tick_count = Math.max(2, Math.floor((document.body.clientWidth - 80) / 18));

        const stride = Math.ceil(days / tick_count);

        // find first and last valid date (yes this is janky as hell)
        const len = this.internal.axis.x.config.tickValues.length;
        let i = 0;
        let first = 0;
        for (; i < len; i++) {
            if (domain[0] <= this.internal.axis.x.config.tickValues[i]) {
                first = i;
                break;
            }
        }
        let last = Math.min(i, len-1);
        for (; i < len; i++) {
            if (domain[1] < this.internal.axis.x.config.tickValues[i]) {
                break;
            }
            last = i;
        }
        last = Math.max(1, last);

        // Without this offset we have a tendency for wasted padding on left or right
        const offset = Math.floor(((last) % stride) / 2);

        d3.selectAll(this.internal.config.bindto + " .bb-axis-x .tick tspan").each(
            function(v) {
                if (first <= v.index && v.index <= last) {
                    this.textContent = ((v.index % stride) == offset) 
                        ? v.splitted
                        : "";
                } else {
                    this.textContent = "";
                }
            }
        );
    }

    obj.padding = true;

    obj.title.padding = {
        top:20,
        bottom:5
    };

    obj.tooltip = {
        order: null,
        grouped: true,
        linked: false,
        format: {
            title: function(d) { 
                return d.toLocaleDateString(
                    undefined, 
                    { 
                        weekday: 'short', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    }
                );
            },
            value: function(value, ratio, id) { 
                return value.toLocaleString(
                    undefined, 
                    { 
                        maximumFractionDigits: 1 
                    }
                ); 
            }
        }
    };
}

function plot_obj_observed_v_expected(data) {
    var obj = {
        title: {
            text: "Observed & Expected Weight Loss [lbs]"
        },
        data: {
            x: "x",
            columns: [
                ["Observed Weight Loss [lbs]", ...data["Observed Weight Loss [lbs]"]],
                ["Observed Weight Loss [lbs] (SMA)", ...data["Observed Weight Loss [lbs] (SMA)"]],
                ["Expected Weight Loss [lbs]", ...data["Expected Weight Loss [lbs]"]],
                ["Expected Weight Loss [lbs] (SMA)", ...data["Expected Weight Loss [lbs] (SMA)"]],
                ["x", ...data["Date"]]
            ],
            types: {},
            colors: {
                // data1: "red",
                // data2: "green"
            }
        },
        bindto: "#Observed_v_Expected_lbs",
    };
    plot_obj_set_options(obj, data);

    // obj.data.colors["Observed Weight Loss [lbs]"] = "rgba(30,50,190,0.8)";

    obj.data.types["Observed Weight Loss [lbs]"] = "scatter";
    obj.data.types["Observed Weight Loss [lbs] (SMA)"] = "area";
    obj.data.types["Expected Weight Loss [lbs]"] = "scatter";
    obj.data.types["Expected Weight Loss [lbs] (SMA)"] = "area";

    return obj;
} // plot_obj

function plot_obj_daily_calories(data) {
    var obj = {
        title: {
            text: "Daily Calories [C]"
        },
        data: {
            order: null,
            x: "x",
            columns: [
                ["Resting Energy [C]", ...data["Resting Energy [C]"]],
                ["Active Energy [C]", ...data["Active Energy [C]"]],
                ["Food Energy [C]", ...data["Food Energy [C]"]],
                ["x", ...data["Date"]],
            ],
            type: "bar",
            types: {},
            groups: [
                ["Resting Energy [C]", "Active Energy [C]", "Food Energy [C]"]
            ],
        },
        bindto: "#Daily_Calories_C",
    };
    plot_obj_set_options(obj, data);

    return obj;
} // plot_obj_daily_calories

function plot_obj_tdee(data) {
    const name = "TDEE [C]";
    const fields = ["Resting Energy [C]", "Active Energy [C]"];

    var obj = {
        title: {
            text: name
        },
        data: {
            order: null,
            x: "x",
            columns: [
                ["x", ...data["Date"]],
            ],
            type: "bar",
            types: {},
            groups: [fields],
        },

        bindto: "#" + to_id_name(name),
    };
    plot_obj_set_options(obj, data);
    // obj.axis.y.max = 0;
    // obj.axis.y.padding.bottom = 10;
    // obj.axis.y.min = -6000;
    // obj.axis.y.outer = false;


    for (field of fields) {
        obj.data.columns.push( [field, ...data[field]] );    
    }

    sum = [...data[fields[0]]];
    for (let i = 1; i < fields.length; i++) {
        sum = sum.SumArray(data[fields[i]]);
    }
    const sma = simpleMovingAverage(sum, 7);
    const sma_name = name + " (SMA)";
    obj.data.columns.push( [sma_name, ...sma]);
    obj.data.types[sma_name] = "line";

    return obj;
} // plot_obj_tdee

function plot_obj_daily_delta(data, field) {
    const dd = daily_delta(data[field]);
    const sma = simpleMovingAverage(dd, 7);
    const field_sma = field + " (SMA)";

    var obj = {
        title: {
            text: "Daily Delta of " + field
        },
        data: {
            x: "x",
            columns: [
                [field, ...dd],
                [field_sma, ...sma],
                ["x", ...data["Date"]]
            ],
            types: {},
        },
        bindto: "#Daily_Delta_" + to_id_name(field),
    };
    plot_obj_set_options(obj, data);
    obj.grid.y.lines = [{ value:0 }];

    obj.data.types[field] = "scatter";
    obj.data.types[field_sma] = "area";

    return obj;
} // plot_obj_daily_delta

function plot_obj_cumulative(data, field) {
    const cs = cumsum(data[field]);

    var obj = {
        title: {
            text: "Cumulative " + field
        },
        data: {
            x: "x",
            columns: [
                [field, ...cs],
                ["x", ...data["Date"]]
            ],
            type: "area",
        },
        bindto: "#Cumulative_" + to_id_name(field),
    };
    plot_obj_set_options(obj, data);

    return obj;
} // plot_obj_cumulative

function plot_obj_simple(data, field) {
    var obj = {
        title: {
            text: field
        },
        data: {
            x: "x",
            columns: [
                [field, ...data[field]],
                ["x", ...data["Date"]]
            ],
            types: {},
        },
        bindto: "#" + to_id_name(field),
    };
    plot_obj_set_options(obj, data);

    obj.data.types[field] = "area-spline";
    return obj;
} // plot_obj

function plot_obj(data, field) {
    const sma = simpleMovingAverage(data[field], 7);
    const field_sma = field + " (SMA)";

    var obj = {
        title: {
            text: field
        },
        data: {
            x: "x",
            columns: [
                [field, ...data[field]],
                [field_sma, ...sma],
                ["x", ...data["Date"]]
            ],
            types: {},
            color: {},
            colors: {}
        },
        bindto: "#" + to_id_name(field),
    };
    plot_obj_set_options(obj, data);

    // obj.data.colors[field] = "rgba(102, 153, 204, 255)";
    // obj.data.colors[field] = "rgb(102 153 204)";

    obj.data.types[field] = "scatter";
    obj.data.types[field_sma] = "area";

    return obj;
} // plot_obj

var d;
function update(results) {
    const raw_data = transpose(results);
    const data = compute_derived(raw_data);
    d = data;

    { // Weight            
        var weight = plot_obj(data, "Weight [lbs]");
        weight.axis.y.min = arrayMin(data["Weight [lbs]"]) - 5;
        bb.generate(weight);

        var delta = plot_obj_daily_delta(data, "Weight [lbs]");
        bb.generate(delta);

        var weekly = plot_obj_simple(data, "Weekly Delta of Weight [lbs]");
        bb.generate(weekly);

        var cumulative_active = plot_obj_cumulative(data, "Active Weight Loss [lbs]");
        bb.generate(cumulative_active);

    }

    { // Nutrition
        var protein = plot_obj(data, "Protein [g]");
        bb.generate(protein);

        var fat = plot_obj(data, "Fat [g]");
        bb.generate(fat);

        var carbs = plot_obj(data, "Carbs [g]");
        bb.generate(carbs);
    }

    { // Exercise 
        var steps = plot_obj(data, "Walking [Steps]");
        var step_format = function (s) { return (s/1000).toLocaleString() + "k"; };
        steps.axis.y.tick.format = step_format;
        steps.axis.y2.tick.format = step_format;
        bb.generate(steps);

        var miles = plot_obj(data, "Walking [mi]");
        bb.generate(miles);

        var cumulative_miles = plot_obj_cumulative(data, "Walking [mi]");
        bb.generate(cumulative_miles);
    }

    { // Calories
        var daily_calories = plot_obj_daily_calories(data);
        bb.generate(daily_calories);

        var deficit = plot_obj(data, "Deficit [C]");
        bb.generate(deficit);

        var calories = plot_obj(data, "Food Energy [C]");
        bb.generate(calories);

        var tdee = plot_obj_tdee(data);
        bb.generate(tdee);

        var active = plot_obj(data, "Active Energy [C]");
        // active.axis.y.padding.bottom = 10;
        bb.generate(active);

        var resting = plot_obj(data, "Resting Energy [C]");
        // resting.axis.y.padding.bottom = 10;
        bb.generate(resting).axis.range({
            max:arrayMax(data["Resting Energy [C]"]),
            min:arrayMin(data["Resting Energy [C]"])
        });
    }

    { // Analysis
        var comparison = plot_obj_observed_v_expected(data);
        bb.generate(comparison);

        var anomalous = plot_obj(data, "Anomalous Weight Loss [lbs]");
        bb.generate(anomalous);
    }
}

function main() {
    const url_params = new URLSearchParams(window.location.search);
    var url_csv = url_params.get('csv');
    const csv = (url_csv == null) ? "Data-Raw.csv" : url_csv;

    const f = Papa.parse(csv, {
        download: true,
        complete: function(results, file) {
            update(results.data);
        } 
    });
}
main()
collapsible();
</script>
</body>
</html>